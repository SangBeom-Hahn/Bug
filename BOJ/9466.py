'''
팀 프로젝트
1] 팀원수에 제한 X = 모든 학생이 팀이라서 1팀만 있어도 됨
2] 모든 학생은 플젝 같이 하고 싶은 학생 단 1명만 선택
3] 혼자하고 싶으면 자기자신 선택도 가능
4] 속하지 않는 학생도 있음

ex) 학생수 1명 = 자기자신 선택 = 모든 학생이 1팀
학생수 3명 1>2 / 2>3/ 3>1 = 모든학생이 1팀

- 어제 버전
1. 모경수(prt, n=1)
1) 사이클이 있는 애들을 팀이 있는 거임
2) 나로 시작해서 다시 나를 만나면 팀이고 모든 노드를 방문 처리한다.
3) 나를 안 만나면 나는 팀이 없는 애임 = 지금까지 만난 애들을 저장하고 다시 방문 해제함
    1] 속하지 않은 학생 + 1
4) 모든 노드를 순회하면서 방문하지 않은 노드에 bfs를 돌림

-> 이 방법의 문제점
1) 1에서 시작해서 3-3은 사이클인데 3-3 싸이클을 추가 안하고 다시 3을 bfs 호출하게 함
2) 이렇게 되면 1 -> 2를 보고 2는 ~ 100만까지 싸이클이면 2~100만 도는게 2번 발생함

-> 내 예상
3) 그래서 1에서 시작해서 3-3을 싸이클 처리를 하는게 필요함

-> 정답
1)  1 -> 3이 싸이클이 아닌데 만약 4->1이면 1을 방문처리해서 4->1->3이 안되게 해야함
이미 1을 만나면 싸이클이 아닌 것을 알아야 함
2) 3->3이 싸이클인데 1->3이면 1은 싸이클이 아님을 알아야 함
    
3) 경우
1] x에서 시작했을 때, 사이클에 포함된 학생 혹은 싸이클에 포함되지 않은 학생을 만나면
x는 사이클 비포함하고 x부터 지금까지 방문한 학생은 비포함 학생이다.

2] x에서 시작햇을 때, 최초 재방문 노드가 y면 x는 비포함, y는 포함이다. y에서 출발해
y까지 만나는 학생들은 포함학생들로 치고, x에서 y까지 가는 학생들은 비포함이다.

3] x에서 출발해 x를 재방문하면 x에서 출발해 x까지 만나는 학생을 모두 포함

4) 근데 이 문제는 visit에 값을 나누는 것도 실력이지만, 이 경우를 생각하는게 더 어려울 듯

- 오늘 버전
1. 모경수 (prt, n=1)
1) x에서 시작해서 최초 재방문 노드를 봄
    1] 경우3 = 최초 재방문 노드가 x면 모든 학생 방문처리 유지
    2] 경우2 = 최초 재방문 노드가 x가 아니면 최초에서 출발해서 다시 최초로 올때까지 애들은
    방문 유지, 그 외 애들은 팀에 속하지 못하는 학생으로 치고 방문 유지
2) 경우1 = x에서 시작해서, 방문한 애를 만나면 지금부터 x까지 비포함(근데 이게 경우3과 중복돼서 상태체크를 분할해야함)

(여기!!!)
1. 리얼 모경수 (prt, n=1)
1) x에서 시작해서 최초 재방문 노드를 봄
    1] 경우3 = 최초 재방문 노드가 x면 모든 방문한 학생 싸이클 포함 처리
    2] 경우2 = 최초 재방문 노드가 x가 아니면 최초에서 출발해서 다시 최초로 올때까지 애들은
    싸이클 포함 처리, 그 외 싸이클 비포함 처리
2) 경우1 = x에서 시작해서, 싸이클, 혹은 비싸이클 애를 만나면 지금까지 방문한 애들
비싸이클 처리
3) visit을 순회해서 비싸이클 애들의 개수를 셈



* t : 테케수
n : 학생수
1 ~ n번 학생이 선택한 학생 번호
출 : 속하지 못한 학생 수

2. nlogn
'''
from collections import deque

# 1) x에서 시작해서 최초 재방문 노드를 봄
#     1] 경우3 = 최초 재방문 노드가 x면 모든 방문한 학생 싸이클 포함 처리
#     2] 경우2 = 최초 재방문 노드가 x가 아니면 최초에서 출발해서 다시 최초로 올때까지 애들은
#     싸이클 포함 처리, 그 외 싸이클 비포함 처리
def bfs(x):
    start = x
    teams = set()
    while(True):
        visit[x] = 1
        teams.add(x)
        
        x = graph[x]
        if(visit[x] == 1 and x == start): #  최초 재방문 노드를 봄
            for ele in teams:
                visit[ele] = 2
            return

# 2) 경우1 = x에서 시작해서, 싸이클, 혹은 비싸이클 애를 만나면 지금까지 방문한 애들
# 비싸이클 처리        

        if(visit[x] == 1 and x != start):
            first = x
            x = graph[x]
            while(first != x):
                teams.remove(x)
                visit[x] = 2
                x = graph[x]
            visit[x] = 2 # 최초인 애도 싸이클 포함
            teams.remove(x)
            
            for ele in teams:
                visit[ele] = 3
            return
            
        if(visit[x] == 2 or visit[x] == 3):
            for ele in teams:
                visit[ele] = 3
            return
            
  
# visit 0 = 노방문, 1=방문, 2=싸이크, 3=비싸이클

t = int(input().strip())
for _ in range(t):
    n = int(input().strip())
    visit = [0] * (n+1)
    graph = [0] + list(map(int, input().split()))

    for i in range(1, n+1):
    # for i in range(2, 3):
        if(not visit[i]):
            bfs(i)
        # print(visit)
        
        
    print(visit.count(3))