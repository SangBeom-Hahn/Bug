'''
n개의 문제, 정답시 각각 문제마다 선물 컵라면 개수가 있음
문제 1개 = 시간 1 걸림
데드라인 ex 3 = 시간 3안에 풀어야 함

문제    데드라인    컵라면
1       1           6
2       1           7
3       3           2
4       3           1
5       2           4
6       2           5
7       6           1

-> 데드라인 오름
문제    데드라인    컵라면      if 길이 같?     if(컵 <= 솔브헤드)          solve
1       1           6           x                                          6
2       1           7           o               7 <= 6 x 현재 컵이 더큼     7(6은 팝)
5       2           4
6       2           5
3       3           2
4       3           1
7       6           1

문제    데드라인    컵라면      if 길이 같?     if(컵 <= 솔브헤드)          solve
2       1           7           x                                          7
1       1           6           o               6 <= 7 ㅇ 헤드가 더큼     7(컨티뉴)
6       2           5           x                                        5, 7
5       2           4

-> 중요점
1. 데드라인이 빠른 순으로 봐야함
2. 해당 데드라인에서 가장 컵라면 수가 큰걸 찾기 위해서는 
현재 데드라인 뽑고 그 데드라인의 컵라면과 전체 숙제를 순회해서 대소 비교를 하는게 아니라
그 다음 for문을 보면 자연스럽게 다음과 비교가 된다. 따라서 동일 데드라인을 보게 되고
동일 데드라인일때 컵라면 대소 비교를 하는 코드가 들어가야함

3. 데드라인이 2인 문제가 최초 2개 있으면 그 두 문제는 둘다 풀수 있음, 컵이 8인 하나만 
푸른게 아님

데드 2 2 
컵   7 8

+ 1초안에 하나 2초안에 하나가 아니고 2인거 두개 풀수 있다는 거임
데드 1, 2, 2
컵   2, 4, 5

4. 데드라인과 지금까지 푼 문제 수가 같으면 가장 컵이 작은거 하나만 빼야해서 힙을 쓰는
거임








문제 번호 : 2 6 3 1 7 5 4 -> 문제 푸는 순서를 고를 수 있음
걸린 시간 : 1 2 3 4 5 6 7 -> 각 문제가 이만큼 시간 걸림
데드라인  : 1 2 3 1 6 2 3 -> 데드라인

데드 1 2 2 3 3
컵   5 1 2 8 6

-> 방식 1
1초만에 풀어야 하는 문제 = 1, 2
2초 = 5, 6
3초 = 3, 4
4초 = x
5초 = x
6초 = 7
데드라인이 짝은 문제를 하나 뽑고 그 데드라인과 같은 문제들 순회하면서 컵라면 최대값구하고
그 데드라인인 값들 전부 삭제해서 다시 힙 만들어야 함 = n^2

1초에 풀 수 있는 문제 = 1 2 3 4 5 6 7
2초 = 3 4 5 6 7
3초 = 3 4 7
4초 = 7
5초 = 7
6초 = 7
7초 = x
1초에 풀수 있는 문제 중에서 컵라면이 가장 큰 값을 꺼내면 ex) 7
1초에 7풀고 끝인데
1초에 1, 2를 풀면 4초에도 7 풀수 있어서 최대값이 아님
즉, 1초엔 데드라인에 가까운 문제를 풀어야 함


-> 백, 순열 = 시간 초과
-> 

1. 모경수(prt, n=1)
1) 데드라인이 작은 수부터 봄
2) 데드라인이 현재 길이보다 크면 푸시
3) 작으면 못넣음
4) 같으면 더 컵이 큰 걸 넣음

* n : 문제 수
n개의 데드라인, 컵라면 수
출 : 받을 수 있는 최대 컵라면 수

2. nlogn

'''

import heapq, sys
input = sys.stdin.readline

n = int(input())
work = [list(map(int, input().split())) for _ in range(n)]

work.sort()
result = []

for deadline, cup in work:
    if(deadline == len(result)):
        if(cup >= result[0]):
            heapq.heappop(result)
        else:
            continue
    heapq.heappush(result, cup)

# print(result)    
print(sum(result))