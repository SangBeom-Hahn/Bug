'''
일정이 있는 곳에 코팅지를 붙임
규칙 : 
1] 연속된 두 일자에 일정이 1개 이상 있으면 연속
2] 연속된 모든 일정은 하나의 직사각형
3] 연속된 일정 모두 감싸는 가장 작은 직사각형의 크기로 코팅지를 오림

달력에 일정 채우기 규칙:
1] 일정 : 시작과 끝 날짜 포함(시작, 끝이 같은 일정도 있음)
2] 시작일이 가장 앞선 일정부터 차례대로 채움
3] 시작일이 같으면 기간이 긴 것부터 위에 채움 (일정은 가능한 최 상단에 배치)

ex) 
5 6     요렇게 2개가 일정이 겹쳐서 쌓임 = 높이 2
5 7     표기한 일정 길이만큼은 무조건 테이프가 필요함 = 3
결과 : 길이 * 쌓인 높이 = 3 * 2

0 1 2 3 4 5 6 7
0 0 0 0 0 1 1 1
0 0 0 0 0 1 1

0 0 0 0 0 2 2 1

시끝층
5 7 0   겹치는게 없음 0층
5 6 1   얘가 앞에꺼에 겹친다, 앞에꺼가 0층이네? 0+1 = 1층


ex) 
시끝층
2 4 0   겹치는게 없음 0층     
4 5 0   얘가 앞에ㅔ꺼에 겹침, 앞에꺼가 0층이네? 0+1 = 1층
5 7 0   얘가 앞에꺼에 겹침, 앞에꺼가 1층이네? 0층
5 6 0   얘가 앞에꺼에 겹침, 앞에가 0층이네? 2층?

시작일이 앞선것부터 채우느라 2 4 위에 4 5가 쌓임
4 5 와 5 7도 겹치는데 4 5가 쌓여서 5 7이 맨 위가 됨

0 1 2 3 4 5 6 7
0 0 1 1 1 1 1 1
0 0 0 0 1 1

0 0 1 1 2 2 1 1 결과 : 길이 * 쌓인 높이 = 6 * 2



ex) 
4 5     2 4가 없어서 4 5가 1층이었으면 5 7이 2층이었을 거임
5 7

2] 시작일이 가장 앞선 일정부터 차례대로 채움 -> 시작일대로 채우는데 겹치면 한칸 위
3] 시작일이 같으면 기간이 긴 것부터 위에 채움 (일정은 가능한 최 상단에 배치)
-> 시작일이 같은게 있으면 긴거부터함

ex) 
2 4
4 5 (겹쳐서 한칸 위)
5 7 (긴거부터 넣음 + 안 겹쳐서 그냥 넣음)
5 6 (겹쳐서 두칸 위)
7 9 (겹쳐서 한 칸 위)
11 12
12 12

0 1 2 3 4 5 6 7 8 9
0 0 1 1 1 1 1 1
0 0 0 0 1 1 0 1 1 1
0 0 0 0 0 1 1

1 1 2 3 2 2 1 1 = 3 * 8

ex) 
1 9
2 5 (겹쳐서 1칸 위)
3 4
4 6
8 9

0 1 2 3 4 5 6 7 8 9
0 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1     1 1
0 0 0 1 1
0 0 0 0 1 1 1

0 1 2 3 4 3 2 1 2 2 = 4 * 9


1. 모경수(prt, n=1)
1) 코팅지는 하루라도 연속이 안되는 곳이 생기면 끊는게 최소일거임
2) 시작 순 오른, 끝 순 내림차순
3) 가장 큰 종료 일만큼의 배열 만듬 , 0으로 초기화
4) 시작, 끝 일정 배열에 + 1씩 함
5) 앞에서부터 끝까지 순회
    1] 0이 아니면 가로 길이 ++
    2] 높이 최대값 갱신
    3] 0만나면 (가로 * 높이) 결과에 반영

* n : 일정 개수
n개의 시작, 종료 날짜
출 : 코팅지 면접(최소)

2. nlogn
'''

n = int(input())
days = [0] * 367
for _ in range(n):
    s, e = map(int, input().split())
    for i in range(s, e+1):
        days[i] += 1
    
# print(days)

result = 0
h = w = 0
for day in days:
    if(day != 0):
        w += 1
        if(h < day):
            h = day
    else:
        result += (h * w)
        h = 0
        w = 0
    
print(result)